% !TEX root = ../main.tex

\chapter{Introduction}

In the context of cryptocurrencies, the trust between marketplaces and users is at an all time low. Following the recent bankruptcy and mishandling of customer funds by marketplaces like FTX, users want and need to know that marketplaces have all the funds in their possession. 
Traditional financial institutions commonly rely on audits as the established method to demonstrate their solvency. The outcomes of third-party examinations gain universal acceptance due to the trust placed in these third parties. However, auditing a cryptocurrency marketplace presents certain challenges. 
Audits are not a scalable solution because the funds can be moved around more quickly than in the traditional finance world. This would call for a high-frequency auditing approach, perhaps even daily audits. Here, automating the process becomes advantageous.

Another challenge pertains to trust in the third party, which must be mutual. The institution needs to trust that their data won't be compromised, and the public must trust the authenticity of the audit results. This is where zero-knowledge proofs come into play. 

The proof of solvency uses zero-knowledge to demonstrate, without revealing any information, that the assets in control are greater than the liabilities. The proof of solvency is made up of a proof of asset and a proof of liabilities, a structure that is self-explanatory.

This paper extends the work done on proof of solvencies, and places particular emphasis on the proof of liabilities. The most prevalent way to implement a proof of liabilities is by using a Merkle Sum Tree. 
In a Merkle tree, every parent node represents the hash of its child nodes. In the Merkle Sum tree, each node additionally holds the balance information. The leaf nodes consist of user IDs along with their respective balances, while the root node contains the hash of the entire tree, summarizing the total balance.

 Alongside the proof of liabilities, there is a proof of inclusion, where you demonstrate that for each customer, their balance is included in the tree. This is achieved by proving the Merkle path, which is sufficient for validation.

This paper explores a way to minimize the cost of doing these proofs everyday, while maintaining complete privacy (i.e the Merkle Tree is kept private).


\section{Outline}

The chapter 2 gives the background information needed to understand this paper.
It elaborates on Bitcoin, including its transactions, the network, proof-of-work, and Merkle Tree. Marketplaces are also discussed. 
Additionally, the chapter delves into Zero Knowledge, covering non-interactive proofs, SNARKs, and arithmetic circuits.
The concept of proof of solvency, with a focus on real-world applications, is introduced. 

Chapter 3 start going deeper into zero knowledge, more specifically the different recursion techniques, which will be used to reduce the proof size and make 
daily proofs easier.
The techniques include aggregation, recursion schemes, accumulation and folding scheme.

Finally, chapter 4 explores the proof and circuit construction of the thesis.
We start with a simple circuit for the proof of liabilities, as well as a circuit for the proof of inclusion for a merkle tree.
We modify the first proof of inclusion to prove the inclusion of many merkle tree at the same time, using the folding scheme.
We adopt an alternate strategy for the proof of liabilities, aiming to reduce the size of generating the proof on the second day, 
given the original Merkle tree is already established. This involves developing a secondary circuit that constructs a Merkle tree, utilizing an initial Merkle tree alongside the changes as input.
We then optimize it using the folding scheme.

The proof of liabilities circuits are evaluated and compared using the number of contraints, the proof time and verifier time. 