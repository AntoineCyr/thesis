% !TEX root = ../main.tex

\chapter{Conclusion}

This thesis introduces a novel approach to generating a compact proof of liabilities. 
Leveraging a fresh circuit design, prior proofs, and the Nova folding scheme, we achieved significant reductions in proof size. 
This smaller proof is suited for daily generation and even higher frequencies, such as hourly updates.
Our analysis demonstrates the superior performance of the folding scheme combined with the updated circuit compared to the existing model. 
The significance of a concise proof of liabilities cannot be overstated, as it serves as a cornerstone for broader adoption of robust proof of solvency.

To complete the proof of solvency for marketplace integration, a proof of assets is imperative. 
One challenge in this endeavor lies in conducting proofs for multiple currencies. 
However, by employing the folding scheme, we can segment the proof of assets into currency-specific proofs before generating the folded proof, mitigating this complexity.

Despite these advancements, several security considerations remain. 
A key vulnerability is the reliance on users to verify their inclusion proofs, as insufficient does not guarantee a valid tree. 
Additionally, the system assumes the validity of the state used in each proof, requiring verifiers to check every proof individually. 
To address this, a promising direction for future work is to incorporate recursive proofs alongside the existing folding scheme. 
Each recursive proof would verify the previous proof, enabling a verifier to validate only the latest proof without trusting the initial state of the tree. 

Another area for improvement are exploring alternative SNARK designs, testing different hash algorithms or optimizing the number of constraints. 
This paper uses Groth16 to benchmark different circuit designs, but other SNARKs could address vulnerabilities, such as post-quantum risks or the trusted setup required by Groth16. 
In similar fashion, other hash algorithms have different degree of security and different speed. You could optimize for either depending on the need. Other potential hashes often use in 
zero knowledge includes Poseidon and Keccak. 

The number of constraints could also be optimized. The current implementation uses a naive construction for the constraints, insuring that the construction is secure. It could be worth exploring merging
some constraints together to minimize their number.

Finally, before deploying the code in production, a thorough audit is essential. 
While the Merkle tree design prevents proving false balances, the constraints must be correctly implemented and comprehensive to ensure this guarantee. 
Rigorous auditing will be critical to validate the circuit's integrity.

By addressing these security and optimization challenges, the proposed proof of liabilities system can pave the way for scalable, 
secure, and practical solvency proofs in blockchain-based marketplaces.