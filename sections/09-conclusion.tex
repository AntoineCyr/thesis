% !TEX root = ../main.tex

\chapter{Conclusion}

This thesis introduces a novel approach to generating a compact proof of liabilities. 
We leveraged a fresh circuit design, prior proofs, and the Nova folding scheme to achieve significant reductions in proof size. 
This smaller proof suits daily generation and even higher frequencies, such as hourly updates.
Our analysis demonstrates the superior performance of the folding scheme combined with the updated circuit compared to the existing model. 
The significance of a concise proof of liabilities cannot be overstated, as it serves as a cornerstone for the broader adoption of robust proof of solvency.

A proof of assets is imperative to complete the proof of solvency for marketplace integration. 
One challenge in this endeavor lies in conducting proofs for multiple currencies. 
However, by employing the folding scheme, we can segment the proof of assets into currency-specific proofs before generating the folded proof, mitigating this complexity.

Despite these advancements, several security considerations remain. 
A key vulnerability is the reliance on users to verify their inclusion proofs, as insufficient does not guarantee a valid tree. 
Additionally, the system assumes the validity of the state used in each proof, requiring verifiers to check every proof individually. 
To address this, incorporating recursive proofs alongside the existing folding scheme is a promising direction for future work. 
Each recursive proof would verify the previous proof, enabling a verifier to validate only the latest proof without trusting the tree's initial state. 

Another area for improvement is exploring alternative SNARK designs, testing different hash algorithms, or optimizing the number of constraints. 
This paper uses Groth16 to benchmark different circuit designs, but other SNARKs could address vulnerabilities, such as post-quantum risks or the trusted setup required by Groth16. 
Similarly, other hash algorithms have different degrees of security and different speed. We could optimize for either, depending on the need. Other potential hashes are often used in 
zero-knowledge includes Poseidon and Keccak. 

The number of constraints could also be optimized. The current implementation uses a naive construction for the constraints, ensuring the construction is secure. It could be worth exploring merging
some constraints together to minimize their number.

Finally, a thorough audit is essential before deploying the code in production. 
While the Merkle tree design prevents proving false balances, the constraints must be correctly implemented and comprehensive to ensure this guarantee. 
Rigorous auditing will be critical to validate the circuit's integrity.

By addressing these security and optimization challenges, the proposed proof of liabilities system can pave the way for scalable, 
secure, and practical solvency proofs in blockchain-based marketplaces.