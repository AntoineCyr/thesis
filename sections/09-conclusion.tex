% !TEX root = ../main.tex

\chapter{Conclusion}

By combining a new circuit design, prior proofs, and the Nova folding scheme, we achieve significant reductions in proof size, enabling daily or even hourly generation.
While the relative cost of each proof decreases with higher frequency, the absolute cost rises compared to current monthly proofs. This tradeoff is worthwhile, as monthly proofs are insufficient. 
Smaller exchanges may adopt this approach more easily, given their lower rate of changes.
Our analysis confirms the superior performance of the folding scheme with the updated circuit, establishing concise liability proofs as a cornerstone for robust solvency systems.

A proof of assets remains necessary to complete proof of solvency. Handling multiple currencies is a key challenge, but the folding scheme allows asset proofs to be segmented per currency before aggregation, reducing complexity.

Security considerations persist. Reliance on users to verify inclusion proofs is insufficient to guarantee a valid tree, and each proof assumes state validity, forcing verifiers to check all proofs individually. 
Recursive proofs offer a solution: each proof verifies the previous one, allowing a verifier to validate only the latest proof.

Performance can also be improved. The change circuit can be parallelized, unlike the folding circuit, which behaves like a linked list. 
This makes the change circuit central to the long-term goal of live proving for example, parallelizing 100 change proofs in a single block before aggregation.

Further work includes exploring alternative SNARK designs, testing different hash functions, and optimizing constraint counts. While Groth16 provides benchmarks, other SNARKs may mitigate trusted setup or post-quantum risks. 
Likewise, Poseidon or Keccak may offer better tradeoffs in speed or security. 
The current implementation uses a secure but naive constraint construction, leaving room for merging constraints to reduce overhead.

Finally, rigorous auditing is essential before deployment. While the Merkle tree design prevents false balances, correctness depends on comprehensive and accurate constraint implementation.

By addressing these challenges, the proposed system can deliver scalable, secure, and practical solvency proofs for blockchain marketplaces, and represents the right step towards live proving: a proof every block.